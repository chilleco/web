services:
  api:
    image: ${REGISTRY}/${PROJECT_NAME}/api:latest
    env_file: .env
    environment:
      API: ${PROTOCOL}://${EXTERNAL_HOST}/api/
      WEB: ${PROTOCOL}://${EXTERNAL_HOST}/
      RELEASE: ${RELEASE}
    volumes:
      - ${DATA_PATH}/load:/data/load
      - ${DATA_PATH}/backup:/backup
      # - ./scripts:/app/scripts
      # For logs
      - ${DATA_PATH}/logs/api.log:/logs/app.log
      - ${DATA_PATH}/logs/api.err:/logs/app.err
    ports:
      - target: 5000
        published: ${API_PORT}
        protocol: tcp
        mode: ingress
    command: bash -c "cd /app && uv run uvicorn main:app --host 0.0.0.0 --port 5000 --proxy-headers"
    # command: bash -c "cd /app && uvicorn app:app --host 0.0.0.0 --port 5000 --proxy-headers"
    deploy:
      mode: replicated
      replicas: 1
      placement:
        preferences:
          - spread: node.labels.worker
        max_replicas_per_node: 3
      update_config:
        parallelism: 1
        delay: 10s
        order: start-first
      restart_policy:
        condition: on-failure # unless-stopped
        delay: 5s
        max_attempts: 3
      resources:
        limits:
          cpus: "2"
          memory: 2G
        reservations:
          cpus: "0.2"
          memory: 256M
      # healthcheck:
      #   test: ["CMD", "curl", "-f", "http://localhost:5000/health" ]
      #   interval: 30s
      #   timeout: 10s
      #   retries: 3

  worker:
    image: ${REGISTRY}/${PROJECT_NAME}/api:latest
    env_file: .env
    environment:
      API: ${PROTOCOL}://${EXTERNAL_HOST}/api/
      WEB: ${PROTOCOL}://${EXTERNAL_HOST}/
      RELEASE: ${RELEASE}
      LOG_FILE: /logs/worker.log
      ERR_FILE: /logs/worker.err
    volumes:
      - ${DATA_PATH}/load:/data/load
      - ${DATA_PATH}/backup:/backup
      # For sitemap
      - ${DATA_PATH}/sitemaps:/data/sitemaps
      - ${DATA_PATH}/sitemap.xml:/data/sitemap.xml
      - ${DATA_PATH}/robots.txt:/data/robots.txt
      # For logs
      - ${DATA_PATH}/logs/worker.log:/logs/worker.log
      - ${DATA_PATH}/logs/worker.err:/logs/worker.err
    command: bash -c "cd /app && uv run taskiq worker --app-dir /app tasks.broker:broker tasks.registry --workers 2 --log-level INFO"
    deploy:
      mode: replicated
      replicas: 1
      placement:
        preferences:
          - spread: node.labels.worker
        max_replicas_per_node: 3
      update_config:
        parallelism: 1
        delay: 10s
        order: start-first
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
      resources:
        limits:
          cpus: "1"
          memory: 1G
        reservations:
          cpus: "0.2"
          memory: 256M

  scheduler:
    image: ${REGISTRY}/${PROJECT_NAME}/api:latest
    env_file: .env
    environment:
      API: ${PROTOCOL}://${EXTERNAL_HOST}/api/
      WEB: ${PROTOCOL}://${EXTERNAL_HOST}/
      RELEASE: ${RELEASE}
      LOG_FILE: /logs/scheduler.log
      ERR_FILE: /logs/scheduler.err
    volumes:
      # For logs
      - ${DATA_PATH}/logs/scheduler.log:/logs/scheduler.log
      - ${DATA_PATH}/logs/scheduler.err:/logs/scheduler.err
    command: bash -c "cd /app && uv run taskiq scheduler --app-dir /app tasks.scheduler:scheduler tasks.registry --log-level INFO"
    deploy:
      mode: replicated
      replicas: 1
      placement:
        preferences:
          - spread: node.labels.worker
        max_replicas_per_node: 3
      update_config:
        parallelism: 1
        delay: 10s
        order: start-first
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
      resources:
        limits:
          cpus: "0.5"
          memory: 512M
        reservations:
          cpus: "0.1"
          memory: 128M

  web:
    image: ${REGISTRY}/${PROJECT_NAME}/web:latest
    env_file: .env
    environment:
      NEXT_PUBLIC_ENV: ${ENV}
      NEXT_PUBLIC_API: ${PROTOCOL}://${EXTERNAL_HOST}/api/
      NEXT_PUBLIC_WEB: ${PROTOCOL}://${EXTERNAL_HOST}/
      NEXT_PUBLIC_NAME: ${NAME}
      NEXT_PUBLIC_LOCALE: ${LOCALE}
      # NEXT_PUBLIC_GOOGLE_ID: ${GOOGLE_ID}
      NEXT_PUBLIC_TG_BOT: ${TG_BOT}
      NODE_OPTIONS: "--max_old_space_size=4096"
      NODE_ENV: "production"
    ports:
      - target: 3000
        published: ${WEB_PORT}
        protocol: tcp
        mode: ingress
    command: ["npm", "start"]
    deploy:
      mode: replicated
      replicas: 1
      placement:
        preferences:
          - spread: node.labels.worker
        max_replicas_per_node: 3
      update_config:
        parallelism: 1
        delay: 10s
        order: start-first
      restart_policy:
        condition: on-failure
      resources:
        limits:
          cpus: "1"
          memory: 4G
        reservations:
          cpus: "0.5"
          memory: 1G

  tg:
    image: ${REGISTRY}/${PROJECT_NAME}/tg:latest
    env_file: .env
    environment:
      API: ${PROTOCOL}://${EXTERNAL_HOST}/api/
      WEB: ${PROTOCOL}://${EXTERNAL_HOST}/
      TG: ${PROTOCOL}://${EXTERNAL_HOST}/tg/
      LOG_FILE: /logs/tg.log
      ERR_FILE: /logs/tg.err
    volumes:
      - ${DATA_PATH}/logs:/logs
    ports:
      - target: 80
        published: ${TG_PORT}
        protocol: tcp
        mode: ingress
    deploy:
      mode: replicated
      replicas: 1
      placement:
        preferences:
          - spread: node.labels.worker
        max_replicas_per_node: 3
      update_config:
        parallelism: 1
        delay: 10s
        order: start-first
      restart_policy:
        condition: on-failure
      resources:
        limits:
          cpus: "0.5"
          memory: 512M
        reservations:
          cpus: "0.1"
          memory: 128M
